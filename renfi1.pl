#!/usr/bin/env perl
use strict;
use warnings;
use POSIX qw(strftime);
use IO::Handle;
use IPC::Open3;
use Symbol qw(gensym);
use Text::CSV_XS;   # REQUIRE this module to be installed

##############################################################################
# Command-line interface
# Required CSV headers (case-sensitive):
#   OD_INSTAME_SRC, AGID_NAME_SRC, OD_INSTAME_DST, AGID_NAME_DST, OD_TSM_LOGON_NAME
##############################################################################
my ($CSV_FILE,$SERVERNAME,$USER,$PASS,$PWFILE,$DELIM) = ("","","","","",",");
my ($DO_RUN,$VERIFY) = (0,0);

while (my $arg = shift @ARGV) {
    if    ($arg eq '-c' or $arg eq '--csv')        { $CSV_FILE   = shift(@ARGV) // "" }
    elsif ($arg eq '--servername')                 { $SERVERNAME = shift(@ARGV) // "" }
    elsif ($arg eq '-u' or $arg eq '--user')       { $USER       = shift(@ARGV) // "" }
    elsif ($arg eq '-p' or $arg eq '--pass')       { $PASS       = shift(@ARGV) // "" }
    elsif ($arg eq '--pwfile')                     { $PWFILE     = shift(@ARGV) // "" }
    elsif ($arg eq '--delim')                      { $DELIM      = shift(@ARGV) // "," }
    elsif ($arg eq '--run')                        { $DO_RUN     = 1 }
    elsif ($arg eq '--verify')                     { $VERIFY     = 1 }
    elsif ($arg eq '-h' or $arg eq '--help')       { print_usage(); exit 0 }
    else { die "Unknown arg: $arg (use --help)\n" }
}

die "ERROR: CSV file required (-c|--csv)\n" unless $CSV_FILE;
-f $CSV_FILE or die "ERROR: CSV not readable: $CSV_FILE\n";

# Password resolution
if ($PWFILE && !$PASS) {
    open my $pfh, "<:encoding(UTF-8)", $PWFILE or die "ERROR: Cannot read --pwfile $PWFILE: $!\n";
    chomp($PASS = <$pfh> // "");
    close $pfh;
}
if ($DO_RUN && $USER && !$PASS) {
    print STDERR "Enter password for '$USER': ";
    system("stty -echo"); chomp($PASS = <STDIN> // ""); system("stty echo"); print STDERR "\n";
}

##############################################################################
# Helpers
##############################################################################
sub nowstamp { return strftime("%Y%m%d_%H%M%S", localtime); }

# Quote a value for dsmadmc (double quotes, internal quotes doubled)
sub q_tsm {
    my ($s)=@_; $s //= "";
    $s =~ s/"/""/g; return qq{"$s"};
}

# Build & run dsmadmc with consistent flags:
# -dataonly/-comma for parseable output, -noconfirm to suppress Y/N prompts
sub build_dsmadmc_cmd {
    my ($tsm_cmd) = @_;
    my @cmd = ("dsmadmc", "-dataonly=yes", "-comma", "-noconfirm");
    push @cmd, "-servername=$SERVERNAME" if $SERVERNAME;
    push @cmd, "-id=$USER"               if $USER;
    push @cmd, "-password=$PASS"         if defined $PASS && $PASS ne "";
    push @cmd, $tsm_cmd;
    return @cmd;
}
sub run_dsmadmc {
    my ($tsm_cmd) = @_;
    my @cmd = build_dsmadmc_cmd($tsm_cmd);
    my $err = gensym;
    my $pid = open3(undef, \my $out, $err, @cmd);
    local $/ = undef;
    my $stdout = <$out> // "";
    my $stderr = <$err> // "";
    waitpid($pid, 0);
    my $rc = $? >> 8;
    return ($rc, $stdout, $stderr);
}

# Query filespaces for node; with -comma output the 2nd column is FILESPACE_NAME
sub fs_list_for_node {
    my ($node) = @_;
    my ($rc, $out, $err) = run_dsmadmc("q filespace $node");
    return () if $rc != 0;
    my @names;
    my $csv = Text::CSV_XS->new({ binary=>1 });
    for my $line (split /\r?\n/, $out) {
        next unless length $line;
        if ($csv->parse($line)) {
            my @f = $csv->fields;
            next unless @f >= 2;
            push @names, $f[1];
        }
    }
    return @names;
}
sub fs_exists {
    my ($node,$fs)=@_;
    for my $n (fs_list_for_node($node)) { return 1 if defined $n && $n eq $fs }
    return 0;
}

# Field cleanup: strip trailing CR (Windows CRLF) and trim spaces
sub clean {
    my ($v)=@_; $v //= "";
    $v =~ s/\r$//; $v =~ s/^\s+|\s+$//g; return $v;
}

# Minimal CSV escaping for the report file
sub csv_escape {
    my ($s)=@_; $s //= "";
    if ($s =~ /[",\r\n]/) { $s =~ s/"/""/g; return qq{"$s"}; }
    return $s;
}

##############################################################################
# Outputs: report & rollback
##############################################################################
my $stamp       = nowstamp();
my $REPORT_PATH = "fs_rename_report_${stamp}.csv";
my $ROLLBACK_SH = "fs_rollback_${stamp}.sh";

open my $rep, ">:encoding(UTF-8)", $REPORT_PATH or die "ERROR: Cannot write $REPORT_PATH: $!\n";
print $rep "node,old_fs,new_fs,action,status,message\n";
close $rep;

open my $rb, ">:encoding(UTF-8)", $ROLLBACK_SH or die "ERROR: Cannot write $ROLLBACK_SH: $!\n";
print $rb "#!/usr/bin/env bash\n";
print $rb "# Rollback script generated by cmod_fs_rename.pl\n";
print $rb "# Each line renames a filespace back to its original value\n\n";
close $rb;
chmod 0755, $ROLLBACK_SH;

sub append_report {
    my ($node,$old,$new,$action,$status,$msg) = @_;
    open my $rfh, ">>:encoding(UTF-8)", $REPORT_PATH or die "Cannot append $REPORT_PATH: $!";
    print $rfh join(",", map { csv_escape($_) } ($node,$old,$new,$action,$status,$msg)), "\n";
    close $rfh;
}
sub append_rollback {
    my ($line) = @_;
    open my $rbfh, ">>:encoding(UTF-8)", $ROLLBACK_SH or die "Cannot append $ROLLBACK_SH: $!";
    print $rbfh "$line\n";
    close $rbfh;
}

##############################################################################
# CSV input via Text::CSV_XS
# - newline handling: open with :encoding(UTF-8) (CRLF is fine)
# - delimiter selectable with --delim
##############################################################################
my $csv = Text::CSV_XS->new({ binary => 1, sep_char => $DELIM, auto_diag => 1 });
open my $fh, "<:encoding(UTF-8)", $CSV_FILE or die "ERROR: Cannot read $CSV_FILE: $!\n";

# Read header and enforce required names
my $header = $csv->getline($fh) or die "ERROR: Empty CSV or cannot read header\n";
$csv->column_names(@$header);
my %idx; for my $i (0..$#$header){ $idx{$header->[$i]} = $i; }
for my $need (qw/OD_INSTAME_SRC AGID_NAME_SRC OD_INSTAME_DST AGID_NAME_DST OD_TSM_LOGON_NAME/) {
    die "ERROR: CSV missing required header: $need\n" unless exists $idx{$need};
}

##############################################################################
# Main loop
##############################################################################
while (my $row = $csv->getline_hr($fh)) {
    my $node     = clean($row->{OD_TSM_LOGON_NAME});
    if ($node eq "") {
        append_report("", "", "", "skip", "SKIPPED", "OD_TSM_LOGON_NAME empty");
        next;
    }

    my $src_inst = clean($row->{OD_INSTAME_SRC});
    my $src_agid = clean($row->{AGID_NAME_SRC});
    my $dst_inst = clean($row->{OD_INSTAME_DST});
    my $dst_agid = clean($row->{AGID_NAME_DST});

    my $old_fs = "/$src_inst/$src_agid";
    my $new_fs = "/$dst_inst/$dst_agid";

    my $tsm_cmd = "rename filespace $node " . q_tsm($old_fs) . " " . q_tsm($new_fs);

    # Default = DRY-RUN
    if (!$DO_RUN) {
        print STDERR "INFO : [DRY] $tsm_cmd\n";
        append_report($node, $old_fs, $new_fs, "rename", "DRY-RUN", "No changes applied");
        next;
    }

    # Pre-checks before renaming
    unless (fs_exists($node, $old_fs)) {
        append_report($node, $old_fs, $new_fs, "rename", "SKIPPED", "old_fs not found");
        next;
    }
    if (fs_exists($node, $new_fs)) {
        append_report($node, $old_fs, $new_fs, "rename", "SKIPPED", "new_fs already exists");
        next;
    }

    print STDERR "INFO : Executing: $tsm_cmd\n";
    my ($rc, $out, $err) = run_dsmadmc($tsm_cmd);
    if ($rc != 0) {
        my $msg = $err || $out || "";
        $msg =~ s/[\r\n,]/ /g;
        append_report($node, $old_fs, $new_fs, "rename", "FAILED", $msg);
        next;
    }

    my $status = "OK";
    my $msg    = "renamed";

    if ($VERIFY) {
        my $has_new = fs_exists($node, $new_fs);
        my $has_old = fs_exists($node, $old_fs);
        if ($has_new && !$has_old) { $msg .= "; verified"; }
        else { $status = "WARN"; $msg .= "; verification mismatch"; }
    }

    append_report($node, $old_fs, $new_fs, "rename", $status, $msg);

    # Rollback line only if we did change something
    if ($status eq "OK" || $status eq "WARN") {
        append_rollback("rename filespace $node " . q_tsm($new_fs) . " " . q_tsm($old_fs));
    }
}
close $fh;

print STDERR "INFO : Done. Report: $REPORT_PATH\n";
print STDERR "INFO : Rollback script: $ROLLBACK_SH\n" if $DO_RUN;

##############################################################################
# Usage
##############################################################################
sub print_usage {
    print <<'USAGE';
Usage:
  cmod_fs_rename.pl -c <file.csv> [--servername STANZA] [-u USER] [-p PASS | --pwfile FILE]
                    [--delim ';'] [--run] [--verify]

What it does:
  - Reads mapping from CSV:
      node_name = OD_TSM_LOGON_NAME
      old_fs    = /OD_INSTAME_SRC/AGID_NAME_SRC
      new_fs    = /OD_INSTAME_DST/AGID_NAME_DST
  - Skips rows with empty OD_TSM_LOGON_NAME and logs them in the report.
  - Default is DRY-RUN (prints planned 'rename filespace', no changes).
  - With --run:
      * Pre-checks: old_fs must exist; new_fs must NOT exist.
      * Executes:  rename filespace <node> "<old_fs>" "<new_fs>"
      * --verify: re-queries filespaces to confirm success.
  - Outputs:
      * CSV report:   fs_rename_report_YYYYmmdd_HHMMSS.csv
      * Rollback .sh: fs_rollback_YYYYmmdd_HHMMSS.sh (reverse rename commands)

dsmadmc flags:
  -dataonly=yes -comma -noconfirm
USAGE
}